---
title: "Genotyping analysis of Tasmanian *Macrocystis pyrifera*"
author: "Cintia Iha"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo = FALSE, warning=FALSE, message=FALSE}
setwd("~/CSIRO-ANACC/Genotyping/Genotyping/")
```
## Genotyping assembly with genome reference

> This tutorial was made to help the scienfic communication and review process for Iha et al. 2022 (unplublished). It is NOT free of errors! And may contains discontinuity throughout the tutorial.


#### Checking quality

After the Illumina sequencing, the samples were demultiplexed in fastq/ directory. All samples had the quality checked with FastQC and visualized with MultiQC.

```{bash, eval = FALSE}
module load fastqc/0.11.9

cd fastq/

for i in *fq.gz
do
        fastqc -t 16 $i
done

multiqc .
```


The samples A7 and A8 were removed from the genotyping assembly due to low coverage.


#### Prepare sample for gstacks

We used assembled genome as reference for SNPs calling. We had to mapped the reads of each individual against the genome before running STACKS. https://catchenlab.life.illinois.edu/stacks/manual/.

The assembly was performed on HPC [Petrichor] (https://www.csiro.au/en/research/technology-space/it/petrichor-hpc) that is based on [SLURM](https://slurm.schedmd.com/slurm.html).
We created one script to run BWA and Samtools for each sample.
First, create the base script:
```{bash, eval = FALSE}
#!/bin/bash

# The name of the job:
#SBATCH --job-name="bwa"

# Multithreaded (SMP) job: must run on one node
#SBATCH --nodes=1
# Maximum number of tasks/CPU cores used by the job:
#SBATCH --ntasks=4

# The amount of memory in megabytes per process in the job:
#SBATCH --mem=20G

# The maximum running time of the job in days-hours:mins:sec
#SBATCH --time=1-0:0:00

# The modules to load:
module load bwa/0.7.17
module load samtools/1.12

# The job command(s)
```

Later, create one script for each sample:
```{bash, eval = FALSE}
mkdir alignment
mkdir alignment/bam

for fastq in $(ls fastq/*.gz)
do
        input=$(basename $fastq | sed 's/-1A.*//')
        echo ${input}
        cat bwa.script > bwa.${input}.script
        echo "bwa mem -t 4 scaffolds.clean.fasta ${fastq} > alignment/${input}.sam" >> bwa.${input}.script
        echo "samtools view -@ 4 -b -T scaffolds.clean.fasta alignment/${input}.sam | samtools sort -@ 4 -o alignment/bam/${input}.bam" >> bwa.${input}.script
done
```

Send all scripts to queue:
```{bash, eval = FALSE}
for i in bwa.*.script ; do sbatch $i ; done
```

With all indivuals mapped against the genome, we performed the SNPs calling with STACK, using population mapping file with "population" and "region":
```{bash, eval= FALSE}
gstacks -I alignments/bam/  -M pop_map -O gstacks2 -t 8
populations -P gstacks2 -M pop_map -r 0.65 --vcf --genepop --fstats --smooth --hwe -t 8
```

The STACK output are saved on gstacks2 directory.

### Checking vcf file from STACKS-Populations

This step is a mix of R and bash commands. We used [VCFtools](http://vcftools.sourceforge.net/) (bash) to calculate relevant information in the vcf file and R to make plots with those information:

#### Using VCFTools

###### **Calculate allele frequency**
```{bash, eval = FALSE}
vcftools --vcf gstacks2/populations.snps.vcf --freq2 --out gstacks
```

###### **Calculate mean depth per individual**
```{bash, eval = FALSE}
vcftools --vcf gstacks2/populations.snps.vcf --depth  --out gstacks
```

###### **Calculate mean depth per site**
```{bash, eval = FALSE}
vcftools --vcf gstacks2/populations.snps.vcf --site-mean-depth --out gstacks
```

###### **Calculate proportion of missing data per individual**
```{bash, eval = FALSE}
vcftools --vcf gstacks2/populations.snps.vcf --missing-indv --out gstacks
```

###### **Calculate proportion of missing data per site**
```{bash, eval = FALSE}
vcftools --vcf gstacks2/populations.snps.vcf --missing-site --out gstacks
```


#### R

```{r, warning=FALSE, message=FALSE}
library(vcfR)
library(tidyverse)
library(ggpubr)
library(poppr)
library(RColorBrewer)
library(tidyr)
library(ggpubr)
library(reshape2)

vcf <- read.vcfR("gstacks2/populations.snps.vcf", verbose = FALSE)
show(vcf)
#Allele frequency and Minimun allele frequency (MAF)
freq <- read_delim("gstacks2/gstacks.frq", delim = "\t", col_names = c("CHROM", "POS", "N_ALLELES", "N_CHR", "a1" ,"a2"), skip = 1)
freq$maf <- freq %>% select(a1, a2) %>% apply(1, function(z) min(z))
summary(freq$maf)
f <- ggplot(freq, aes(maf)) + geom_density(fill = "dodgerblue1", colour = "black", alpha = 0.3)

#Depth per individual
depth_sample <- read_delim("gstacks2/gstacks.idepth", delim = "\t")
d <- ggplot(depth_sample, aes(INDV,MEAN_DEPTH)) + geom_col() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

#Depth per variant
depth_var <- read_delim("gstacks2/gstacks.ldepth.mean", delim = "\t")
summary(depth_var$MEAN_DEPTH)
dv <- ggplot(depth_var, aes(MEAN_DEPTH)) + geom_density(fill = "dodgerblue1", colour = "black", alpha = 0.3) + theme_light() + xlim(0,500)

#Missing per individual
miss_ind <- read_delim("gstacks2/gstacks.imiss", delim = "\t")
m <- ggplot(miss_ind, aes(INDV, F_MISS)) + geom_col() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

#Missing per variant
miss_var <- read_delim("gstacks2/gstacks.lmiss", delim = "\t")
summary(miss_var$F_MISS)
mv <- ggplot(miss_var, aes(F_MISS)) + geom_density(fill = "dodgerblue1", colour = "black", alpha = 0.3)

ggarrange(f, d, dv, m, mv, 
          ncol = 2, nrow = 3)
```


#### Filtering SNPs using VCFTools
```{bash, eval = FALSE}
vcftools --vcf gstacks2/populations.snps.vcf --maf 0.02 --max-missing 0.6 --min-meanDP 5 --max-meanDP 250 --minDP 5 --maxDP 250 --recode --out gstacks2/populations.filtered

```


###### Checking filtered VCF on R
```{r, warning=FALSE, message=FALSE}
vcf <- read.vcfR("gstacks2/populations.filtered.recode.renamed.vcf", verbose = FALSE)
show(vcf)
```


## Genetic population analysis

Workflow based on [Grunwald lab tutorials](https://grunwaldlab.github.io/Population_Genetics_in_R/gbs_analysis.html) and [adegenet tutorial for DAPC](https://github.com/thibautjombart/adegenet/wiki/Tutorials)

First, import data attributes.
```{r, warning=FALSE, message=FALSE}

pop.data <- read_delim("gstacks2/pop_map2.renamed", delim = "\t", col_names = c("SampleID", "Population", "Region", "Phenotype"))
head(pop.data)
```

Check if all the samples in the VCF and the population data frame are included
```{r, warning=FALSE, message=FALSE}
all(colnames(vcf@gt)[-1] == pop.data$SampleID)
```

Convert to genlight object. The genlight object was used to follow analysis.
```{r, warning=FALSE, message=FALSE}
#change order of populations
pop.data$Population <- factor(pop.data$Population, levels=c("A", "B", "C", "D", "E", "F"))

gl <- vcfR2genlight(vcf)
pop(gl) <- pop.data$Population
head(gl)
rm(vcf, pop.data)
```


The first question we want to answer is "how many groups are in the our samples?". Although we collected the samples from different localities, this do not means each site is a true population. We will infer the groups/cluster using K-means approach and Discriminant analysis of principal components (DAPC) [Jombart et al. 2010](https://bmcgenomdata.biomedcentral.com/articles/10.1186/1471-2156-11-94)

##### PCA
First, quick look at PCA.

```{r, warning=FALSE, message=FALSE}
cols <- brewer.pal(n = nPop(gl), name = "Dark2")

pca <- glPca(gl, nf = 2)
#nf = an integer indicating the number of principal components to be retained
barplot(100*pca$eig/sum(pca$eig), col = heat.colors(50), main = "PCA Eigenvalues")
title(ylab="Percent of variance\nexplained", line = 2)
title(xlab="Eigenvalues", line = 1)
```

The plot indicates that we can retain the first 2 PCAs that explain ~39% of the variance

```{r, warning=FALSE, message=FALSE}
pca.scores <- as.data.frame(pca$scores)
pca.scores$pop <- pop(gl)

set.seed(9)
ggplot(pca.scores, aes(x=PC1, y=PC2, colour=pop)) + 
  geom_point(size=2) + 
  stat_ellipse(level = 0.9, size = 0.5) + 
  scale_color_manual(name="Populations", values = cols) + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) + 
  theme_bw()
```


The first PC1 (high Eigenvalues) indicate that south populations are different from north populations. The PC2 differentiated HI from the other south populations. 


> "However, PCA lacks some essential features for investigating the genetic structure of biological populations. First, it does not provide a group assessment, and would require a priori definition of clusters to study population structures. But even then, PCA would not be appropriate to obtain a clear picture of between-population variation (Figure 1). PCA aims to summarize the overall variability among individuals, which includes both the divergence between groups (i.e., structured genetic variability), and the variation occurring within groups ('random' genetic variability). To assess the relationships between different clusters, an adequate method should focus on between-group variability, while neglecting within-group variation." [Jombart et al. 2010](https://bmcgenomdata.biomedcentral.com/articles/10.1186/1471-2156-11-94)



We used find.clusters to determined the groups in our samples and DAPC to determined the population structure. [Reference](https://grunwaldlab.github.io/Population_Genetics_in_R/clustering_plot.html). Good practice for using DAPC were based on [Miller et al. 2020](https://www.nature.com/articles/s41437-020-0348-2)




#### K-means

```{r}
#Set max number of clusters (K)
maxK <- 10

#Create an empty matrix
myMat <- matrix(nrow=10, ncol=maxK)
colnames(myMat) <- 1:ncol(myMat)

#Find clusters and save BIC values in a matrix
for(i in 1:nrow(myMat)){
  grp <- find.clusters(gl, n.pca=40, choose.n.clust = FALSE, max.n.clust = maxK, criterion = "diffNgroup")
  myMat[i,] <- grp$Kstat
}

#Make long data
my_df <- melt(myMat)
colnames(my_df)[1:3] <- c("Group", "K", "BIC")
my_df$K <- as.factor(my_df$K)

# Plot cluster inference results
Kplot <- ggplot(my_df, aes(K, BIC)) + geom_boxplot() + theme_bw() + xlab("Number of groups (K)")
Kplot
```

The results indicate that our samples are structured in 2 or 3 clusters (lower BIC values). However, the best Kstats indicate 2 clusters.

We can compared the original populations with the inferred clusters:

```{r}
table(pop(gl), grp$grp)
table.value(table(pop(gl), grp$grp), col.labels = paste("Inferred_cluster", 1:6), row.labels = levels(pop(gl)))
```

The plot shows that south and north populations are grouped in two distinct clusters.



##### DAPC

Based on the PCA results, we retained two components (n.pca = 2) and two DA eigenvalues (n.da = 2).

```{r, warning=FALSE, message=FALSE}
dapc <- dapc(gl, n.pca = 2, n.da = 2)
scatter(dapc, scree.da=TRUE, posi.da = "bottomright", col = cols, cex = 3, scree.pca = TRUE)

```


Create STRUCTURE-like plot

```{r, warning=FALSE, message=FALSE}
#Create composition plot
dapc.results <- as.data.frame(dapc$posterior)
dapc.results$pop <- pop(gl)
dapc.results$indNames <- rownames(dapc.results)
dapc.results <- pivot_longer(dapc.results, -c(pop, indNames))
head(dapc.results, n = 6)

colnames(dapc.results) <- c("Original_Pop","Sample","Assigned_Pop","Posterior_membership_probability")

t <- ggplot(dapc.results, aes(x=Sample, y=Posterior_membership_probability, fill=Assigned_Pop)) + 
  geom_bar(stat = 'identity') +
  scale_fill_manual(name="Populations", values = cols) +
  facet_grid(~Original_Pop, scales = "free") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +
  labs(y="Posterior membership probability", x=NULL)
t
```









